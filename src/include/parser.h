#ifndef PARSER_H_
#define PARSER_H_

#include <format>
#include <initializer_list>
#include <type_traits>
#include <vector>

#include "expr.h"
#include "stmt.h"
#include "token.h"
#include "token_type.h"

namespace cclox {
/**
 * @brief A boolean value which is true if all the types are `TokenType`
 */
template<typename T, typename... Ts>
constexpr bool all_types_are_tokens =
    std::is_same_v<T, TokenType> && std::conjunction_v<std::is_same<T, Ts>...>;

/**
 * @brief Exception class for parsing errors.
 *
 * ParseError is thrown when the parser encounters an unexpected token
 * or syntax that cannot be parsed according to the grammar rules.
 */
class ParseError : public std::runtime_error {
 public:
  /**
   * @brief Constructs a ParseError with a specific error message.
   * @param message The error message describing the cause of the parsing error.
   */
  explicit ParseError(std::string_view message)
      : std::runtime_error(std::format("ParseError: {}", message)) {}
};

/**
 * @brief The Parser class is responsible for transforming a sequence of tokens
 * into an Abstract Syntax Tree (AST) based on a predefined grammar.
 *
 * The parser follows recursive descent parsing, handling various levels of
 * precedence for expressions such as equality, comparison, terms, factors,
 * unary operations, and primary expressions. It processes each token and
 * constructs the appropriate expression nodes, ultimately returning a pointer
 * to the root of the parsed expression tree.
 *
 * Usage:
 * - Construct the parser with a list of tokens generated by the `Scanner`.
 * - Call `Parse` to parse the tokens into an AST.
 */
class Parser {
 public:
  /**
   * @brief Constructs a Parser instance with the given list of tokens.
   * @param tokens a reference to the vector of tokens generated by the
   * `Scanner`.
   */
  explicit Parser(std::vector<Token> tokens) : tokens_(std::move(tokens)) {}

  auto Parse() -> std::vector<StmtPtr>;

 private:
  auto ParseDeclaration() -> StmtPtr;

  auto ParseVarDeclaration() -> StmtPtr;

  auto ParseStatement() -> StmtPtr;

  auto ParsePrintStatement() -> StmtPtr;

  auto ParseExpressionStatement() -> StmtPtr;

  auto ParseBlockStatement() -> std::vector<StmtPtr>;

  /**
   * @brief Parses an expression. This is the entry point for parsing
   * expressions, delegating to `ParseEquality()` for further processing
   * according to operator precedence.
   * @return A pointer to the parsed expression.
   */
  auto ParseExpression() -> ExprPtr;

  auto ParseAssignment() -> ExprPtr;

  /**
   * @brief Parses an equality expression. Parses expressions involving equality
   * operators (`==` and `!=`). Repeatedly consumes operators of the same
   * precedence level to form a left-associative chain of binary expressions.
   * @return A pointer to the parsed expression.
   */
  auto ParseEquality() -> ExprPtr;

  /**
   * @brief Parses a comparison expression. Parses expressions involving
   * comparison operators (`>`, `>=`, `<`, `<=`). Similar to equality parsing,
   * it chains comparisons into a left-associative binary tree structure based
   * on precedence.
   * @return A pointer to the parsed expression.
   */
  auto ParseComparison() -> ExprPtr;

  /**
   * @brief Parses a term expression. Parses addition and subtraction
   * expressions. Terms are the next level down in precedence after comparisons,
   * allowing for binary operations with `+` and `-` operators.
   * @return A pointer to the parsed expression.
   */
  auto ParseTerm() -> ExprPtr;

  /**
   * @brief Parses a factor expression. Parses multiplication and division
   * expressions. Factors take precedence over terms, allowing for binary
   * operations with `*` and `/` operators.
   * @return A pointer to the parsed expression.
   */
  auto ParseFactor() -> ExprPtr;

  /**
   * @brief Parses a unary expression. Parses unary expressions that begin with
   * a `!` or `-` operator. If a unary operator is present, it recursively
   * parses the next highest-precedence expression as the operand.
   * @return A pointer to the parsed expression.
   */
  auto ParseUnary() -> ExprPtr;

  /**
   * @brief Parses a primary expression. Parses literals (such as `true`,
   * `false`, `nil`, numbers, and strings) and expressions enclosed in
   * parentheses. This method represents the lowest level of precedence.
   * @return A pointer to the parsed expression.
   */
  auto ParsePrimary() -> ExprPtr;

  /**
   * @brief Checks to see if the current token has any of the given types. If
   * so, consumes the token and returns true. Otherwise, returns false and
   * leaves the current token alone.
   * @param type The first token type.
   * @param types The remaining token types.
   * @return true if the token has any of the given types or false otherwise.
   */
  template<typename T, typename... Ts,
           typename = std::enable_if_t<all_types_are_tokens<T, Ts...>>>
  auto Match(T type, Ts... types) noexcept -> bool;

  /**
   * @brief Checks if the current token is of the given type and consumes the
   * token if so. Otherwise, throw an error with the given error message.
   * @param type The token type to check with.
   * @param message The error message to use.
   * @return The currently consumed token.
   */
  auto Consume(TokenType type, std::string_view message) -> Token;

  /**
   * @brief Checks if the next token to be consumed is of a given type.
   * @param type The token type to check.
   * @return true if the token matches the given type or false otherwise.
   */
  auto Check(TokenType type) const noexcept -> bool;

  /**
   * @brief Consumes the current token and returns it.
   * @return The most recently consumed token.
   */
  auto Advance() noexcept -> Token;

  /**
   * @brief Checks if there are any tokens to parse.
   * @return true if there is no token to parse or false otherwise.
   */
  auto IsAtEnd() const noexcept -> bool;

  /**
   * @brief Returns the next token to be parsed.
   * @return The next token to be parsed.
   */
  auto Peek() const noexcept -> Token;

  /**
   * @brief Returns the most recently consumed token.
   * @return The most recently consumed token.
   */
  auto Previous() const noexcept -> Token;

  /**
   * @brief Reports an error at the given token and returns a ParseError
   * exception.
   * @param token The token where the error occurs.
   * @param message The error message.
   * @return A ParseError exception.
   */
  auto Error(const Token& token, std::string_view message) const -> ParseError;

  /**
   * @brief Discards all the tokens of an erroneous statement and advances to
   * the token of the next statement.
   */
  auto Synchronize() noexcept -> void;

  // A list of tokens generated by the Scanner.
  std::vector<Token> tokens_;
  // Pointer to the next token to be parsed.
  uint32_t current_{0};
};
}  // namespace cclox

#endif  // PARSER_H_